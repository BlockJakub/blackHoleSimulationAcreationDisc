<!DOCTYPE html>
<html>

<head>
    <title>Černá Díra - Finální Stabilní Verze</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            background: #000;
        }

        .watermark {
            position:absolute;
            left:20px;
            bottom:20px;
            opacity: 82%;
            background-image: url("img
/logo_jacubaVisualsWeb_V1.3.svg
");
        }
    </style>
</head>

<body>
    <canvas id="vesmir"><div class="watermark"></div></canvas>
    <button id="githubBtn"
        style="position:fixed;top:16px;right:16px;z-index:10;padding:8px 16px;background:#222;color:#fff;border:none;border-radius:6px;box-shadow:0 2px 8px #0008;cursor:pointer;font-size:16px;">GitHub</button>
    <script>
        // Load background image
        const bgImg = new Image();
        bgImg.src = 'img/nebula1.png';
        let bgLoaded = false;
        bgImg.onload = () => { bgLoaded = true; };
        // Tlačítko pro GitHub odkaz
        document.getElementById('githubBtn').addEventListener('click', function () {
            window.open('https://github.com/your-repo-link', '_blank');
        });
        // ...existing code...
        const canvas = document.getElementById('vesmir');
        const ctx = canvas.getContext('2d');
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();
        // Fixní střed - díra se nebude hýbat z místa
        const holePos = { x: canvas.width / 2, y: canvas.height / 2 };
        const viewOffset = { x: 0, y: 0 };
        const mouse = { x: holePos.x, y: holePos.y };

        // ...existing code...
        // ...existing code...

        // PLANETY S MĚSÍCI A MINI PLANETKY
        class Planet {
            constructor(orbiting = false) {
                this.radius = 32 + Math.random() * 40;
                this.color = `hsl(${Math.floor(Math.random() * 360)}, 70%, 55%)`;
                this.moons = Array.from({ length: 3 }, (_, i) => new Moon(this, i));
                this.orbiting = orbiting;
                if (orbiting) {
                    // Eliptická dráha
                    this.ellipseA = Math.max(canvas.width, canvas.height) * 0.36;
                    this.ellipseB = Math.max(canvas.width, canvas.height) * 0.22;
                    this.angle = Math.PI * (277 / 180); // 277° v radiánech
                    this.orbitSpeed = 0.0035; // základní rychlost
                } else {
                    // Circular random distribution for accretion disc
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = (canvas.width * 0.35) * Math.sqrt(Math.random());
                    this.x = holePos.x + radius * Math.cos(angle);
                    this.y = holePos.y + radius * Math.sin(angle);
                }
            }
            update() {
                if (this.orbiting) {
                    // Eliptická dráha, rychlost závisí na vzdálenosti
                    // V protisměru hodinových ručiček
                    // Výpočet aktuální pozice
                    this.angle += this.orbitSpeed * (this.ellipseA / (this.ellipseA + this.ellipseB * Math.abs(Math.sin(this.angle))));
                    // Pozice na elipse
                    this.x = holePos.x + Math.cos(this.angle) * this.ellipseA;
                    this.y = holePos.y + Math.sin(this.angle) * this.ellipseB;
                }
                this.moons.forEach(m => m.update());
            }
            draw() {
                ctx.save();
                // 3D sphere effect with radial gradient
                const grad = ctx.createRadialGradient(
                    this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.1,
                    this.x, this.y, this.radius
                );
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.25, this.color);
                grad.addColorStop(0.7, this.color);
                grad.addColorStop(1, '#222');
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.shadowColor = '#222';
                ctx.shadowBlur = 24;
                ctx.fill();
                ctx.restore();
                this.moons.forEach(m => m.draw());
            }
        }

        class Moon {
            constructor(planet, idx) {
                this.planet = planet;
                this.idx = idx;
                this.angle = Math.random() * Math.PI * 2;
                this.orbitRadius = planet.radius + 18 + idx * 18 + Math.random() * 12;
                this.size = 7 + Math.random() * 7;
                this.speed = 0.008 + Math.random() * 0.008;
                this.color = `hsl(${Math.floor(Math.random() * 360)}, 80%, 70%)`;
            }
            update() {
                this.angle += this.speed;
            }
            draw() {
                const x = this.planet.x + Math.cos(this.angle) * this.orbitRadius;
                const y = this.planet.y + Math.sin(this.angle) * this.orbitRadius;
                ctx.save();
                // 3D sphere effect with radial gradient for moons
                const grad = ctx.createRadialGradient(
                    x - this.size * 0.3, y - this.size * 0.3, this.size * 0.1,
                    x, y, this.size
                );
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.25, this.color);
                grad.addColorStop(0.7, this.color);
                grad.addColorStop(1, '#222');
                ctx.beginPath();
                ctx.arc(x, y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.shadowColor = '#222';
                ctx.shadowBlur = 12;
                ctx.fill();
                ctx.restore();
            }
        }

        class MiniPlanet {
            constructor() {
                this.x = holePos.x + (Math.random() - 0.5) * canvas.width * 0.8;
                this.y = holePos.y + (Math.random() - 0.5) * canvas.height * 0.8;
                this.radius = 12 + Math.random() * 18;
                this.color = `hsl(${Math.floor(Math.random() * 360)}, 60%, 60%)`;
                this.orbitObj = new OrbitObj(this);
            }
            update() {
                this.orbitObj.update();
            }
            draw() {
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 6;
                ctx.fill();
                ctx.restore();
                this.orbitObj.draw();
            }
        }

        class OrbitObj {
            constructor(miniPlanet) {
                this.miniPlanet = miniPlanet;
                this.angle = Math.random() * Math.PI * 2;
                this.orbitRadius = miniPlanet.radius + 10 + Math.random() * 10;
                this.size = 4 + Math.random() * 4;
                this.speed = 0.012 + Math.random() * 0.012;
                this.color = `hsl(${Math.floor(Math.random() * 360)}, 90%, 80%)`;
            }
            update() {
                this.angle += this.speed;
            }
            draw() {
                const x = this.miniPlanet.x + Math.cos(this.angle) * this.orbitRadius;
                const y = this.miniPlanet.y + Math.sin(this.angle) * this.orbitRadius;
                ctx.save();
                ctx.beginPath();
                ctx.arc(x, y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 4;
                ctx.fill();
                ctx.restore();
            }
        }

        // Vytvoření planet a mini planet
        // První planeta bude obíhat černou díru
        const planets = [new Planet(true), new Planet()];
        const miniPlanets = Array.from({ length: 3 }, () => new MiniPlanet());
        // ...existing code...


        // Micro-sparks efekty (globálně)
        const sparks = [];
        function createSpark(x, y) {
            for (let i = 0; i < 12 + Math.random() * 12; i++) {
                sparks.push({
                    x: x,
                    y: y,
                    r: 2.5 + Math.random() * 3.5,
                    dx: (Math.random() - 0.5) * 3.5,
                    dy: (Math.random() - 0.5) * 3.5,
                    life: 18 + Math.random() * 16,
                    color: `rgba(255,${180 + Math.floor(Math.random() * 75)},80,` // brighter yellow-orange
                });
            }
        }
        // ...existing code...
        // 1. VESMÍRNÉ OBJEKTY (asteroidy, prach, plyn, led)
        class CosmicBody {
            constructor() { this.reset(); }
            reset() {
                this.type = Math.floor(Math.random() * 4); // 0=asteroid, 1=prach, 2=led, 3=plyn
                this.angle = Math.random() * Math.PI * 2;
                this.dist = 600 + Math.random() * 900; // začínají dál
                this.speed = (0.0005 + Math.random() * 0.0015);
                this.size = this.type === 0 ? Math.random() * 3 + 1.5 : (this.type === 1 ? Math.random() * 1.2 + 0.3 : Math.random() * 2 + 0.7);
                this.pitch = (Math.random() - 0.5) * Math.PI * 0.8;
                // Barvy podle typu
                if (this.type === 0) this.color = "#bbb"; // asteroid
                else if (this.type === 1) this.color = "#ffeedd"; // prach
                else if (this.type === 2) this.color = "#bdf"; // led
                else this.color = "#aef6ff"; // plyn
                this.opacity = this.type === 1 ? 0.18 + Math.random() * 0.18 : (this.type === 3 ? 0.13 + Math.random() * 0.13 : 1);
                this.fallSpeed = 0.04 + Math.random() * 0.07;
                this.falling = false;
            }
            update() {
                // Pomalu rotuje a přibližuje se ke středu
                if (!this.falling) {
                    this.angle += this.speed * (600 / this.dist);
                    // Gravitace: čím blíž, tím rychlejší drift ke středu
                    this.dist -= 0.04 + 0.09 * (1 - this.dist / 900);
                    if (this.dist < 180 && Math.random() < 0.01) this.falling = true;
                } else {
                    // Padá do středu (rychleji)
                    this.dist -= this.fallSpeed;
                    this.size *= 0.98;
                }
                // Pokud je moc blízko, micro-spark a reset
                if (this.dist < 60) {
                    createSpark(
                        holePos.x + Math.cos(this.angle) * this.dist,
                        holePos.y + Math.sin(this.angle) * this.dist * Math.sin(this.pitch)
                    );
                    this.reset();
                }
            }
            draw() {
                let x = holePos.x + Math.cos(this.angle) * this.dist + viewOffset.x;
                let y = holePos.y + Math.sin(this.angle) * this.dist * Math.sin(this.pitch) + viewOffset.y;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(x, y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }
        // 2. ČÁSTICE DISKU (Jemný plyn, bez čar)
        class Particle {
            constructor() { this.reset(); }
            reset() {
                this.angle = Math.random() * Math.PI * 2;
                // Improved randomization for disc radius
                const minR = 70;
                const maxR = Math.max(canvas.width, canvas.height) * 0.48;
                this.dist = minR + (maxR - minR) * Math.sqrt(Math.random()); // Uniform disc density
                // Enhanced height spread
                let materialAmount = Math.random();
                this.height = (Math.random() - 0.5) * Math.max(canvas.height, canvas.width) * (0.12 + materialAmount * 0.18);
                this.fallSpeed = 0.12 + Math.random() * 0.18 + materialAmount * 0.18;
                this.falling = false;
                // Přidávám více prachových částic (dust)
                const colorVariants = [
                    [120, 255, 255],
                    [255, 220, 120],
                    [255, 120, 200],
                    [180, 255, 180],
                    [255, 255, 255],
                    [220, 220, 220], // dust
                    [200, 200, 180], // dust
                    [255, 245, 210]  // dust
                ];
                this.colorIdx = Math.floor(Math.random() * colorVariants.length);
                this.color = colorVariants[this.colorIdx];
                this.size = Math.random() * 2.5 + 0.3 + materialAmount * 2.2;
                this.speed = (0.006 + Math.random() * 0.01 + materialAmount * 0.008);
                this.opacity = 0.45 + Math.random() * 0.7;
            }
            update() {
                this.angle += this.speed * (160 / this.dist);
                this.dist -= 0.15;
                const minR = Math.max(canvas.width, canvas.height) * 0.45;
                const maxR = Math.max(canvas.width, canvas.height) * 0.5;
                if (this.dist < minR * 0.4) { this.reset(); this.dist = maxR; }
                if (!this.falling) {
                    this.angle += this.speed * (160 / this.dist);
                    this.dist -= 0.10 + 0.08 * (1 - this.dist / (Math.max(canvas.width, canvas.height) * 0.5));
                    if (this.dist < Math.max(canvas.width, canvas.height) * 0.18 && Math.random() < 0.04) {
                        this.falling = true;
                        this.fallTrail = 12 + Math.random() * 10;
                        this.spaghettify = 1;
                    }
                } else {
                    this.dist -= this.fallSpeed * 2.1;
                    this.height *= 0.91;
                    this.size *= 1.04;
                    this.opacity = Math.min(1, this.opacity * 1.09);
                    this.fallTrail--;
                    this.spaghettify *= 1.18; // elongace
                }
                if (this.dist < Math.max(canvas.width, canvas.height) * 0.06) {
                    // Fade-out efekt při pádu do černé díry
                    this.opacity *= 0.82;
                    if (!this._resetTimeout) {
                        createSpark(
                            holePos.x + Math.cos(this.angle) * this.dist,
                            holePos.y + Math.sin(this.angle) * this.dist * 0.22 + this.height
                        );
                        materialSupply -= 0.02;
                        if (materialSupply < 0.5) materialSupply = 0.5;
                        // Náhodné zpoždění a rozptyl při resetu
                        this._resetTimeout = setTimeout(() => {
                            this._resetTimeout = null;
                            // Reset s velkým rozptylem v celém disku
                            const minR = 70;
                            const maxR = Math.max(canvas.width, canvas.height) * 0.48;
                            this.dist = minR + Math.random() * (maxR - minR);
                            this.angle = Math.random() * Math.PI * 2 + (Math.random() - 0.5) * 0.2;
                            this.opacity = 0.45 + Math.random() * 0.7;
                            this.falling = false;
                            let materialAmount = Math.random();
                            this.height = (Math.random() - 0.5) * Math.max(canvas.height, canvas.width) * (0.08 + materialAmount * 0.12) + (Math.random() - 0.5) * 10;
                            this.size = Math.random() * 2.5 + 0.3 + materialAmount * 2.2;
                            this.spaghettify = 1;
                        }, 200 + Math.random() * 800);
                    }
                }
            }
            draw(front) {
                const isBehind = Math.sin(this.angle) < 0;
                if (isBehind === !front) {
                    let cos = Math.cos(this.angle);
                    let x = holePos.x + cos * this.dist + viewOffset.x;
                    let y = holePos.y + Math.sin(this.angle) * this.dist * 0.22 + this.height + viewOffset.y;
                    const [r, g, b] = this.color;
                    // Padající částice zvýraznit, protáhnout a přidat delší ocásek
                    if (this.falling && this.fallTrail > 0) {
                        for (let t = 0; t < 12; t++) {
                            let trailDist = this.dist + t * 13 * this.spaghettify;
                            let trailAlpha = Math.max(0, this.opacity * (0.16 - t * 0.012));
                            ctx.save();
                            ctx.translate(holePos.x + cos * trailDist + viewOffset.x, y);
                            ctx.rotate(this.angle);
                            ctx.beginPath();
                            ctx.ellipse(0, 0, this.size * (1.1 - t * 0.08) * this.spaghettify, this.size * 0.5, 0, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(255,255,200,${trailAlpha})`;
                            ctx.shadowColor = '#fffbe0';
                            ctx.shadowBlur = 8;
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            ctx.restore();
                        }
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(this.angle);
                        ctx.beginPath();
                        ctx.ellipse(0, 0, this.size * 1.5 * this.spaghettify, this.size * 0.7, 0, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255,255,220,${Math.min(1, this.opacity * 1.2)})`;
                        ctx.shadowColor = '#fffbe0';
                        ctx.shadowBlur = 18;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    } else {
                        ctx.fillStyle = `rgba(${r},${g},${b},${Math.min(1, this.opacity * 1.5)})`;
                        ctx.beginPath();
                        ctx.arc(x, y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        // Konstantní přísun materiálu z okolí
        let materialSupply = 1.0;
        function updateMaterialSupply() {
            // Přísun nového materiálu do disku (náhodně, ale konstantně)
            materialSupply += 0.01 + Math.random() * 0.03;
            if (materialSupply > 2.5) materialSupply = 2.5;
        }
        setInterval(updateMaterialSupply, 1200);
        // Počet částic disku podle množství materiálu
        function getParticleCount() {
            return Math.floor(1800 + materialSupply * 1200);
        }
        let particles = Array.from({ length: getParticleCount() }, () => new Particle());
        // Plynulé upravování počtu částic podle materiálu
        setInterval(() => {
            const targetCount = getParticleCount();
            if (particles.length < targetCount) {
                // Přidat nové částice
                for (let i = 0; i < targetCount - particles.length; i++) {
                    particles.push(new Particle());
                }
            } else if (particles.length > targetCount) {
                // Odebrat částice
                particles.splice(0, particles.length - targetCount);
            }
        }, 1200);
        const bodies = Array.from({ length: 80 }, () => new CosmicBody());
        function animate() {
            // Declare ellipse parameters once
            const ellipseA = Math.max(canvas.width, canvas.height) * 0.36;
            const ellipseB = Math.max(canvas.width, canvas.height) * 0.22;
            const discAngle = Math.PI * (277 / 180);
            // Add sparkling dust across the accretion disc
            const sparkleDustCount = 60;
            for (let i = 0; i < sparkleDustCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 90 + Math.random() * (ellipseA - 90);
                let x = holePos.x + Math.cos(angle) * ellipseA * (radius / ellipseA);
                let y = holePos.y + Math.sin(angle) * ellipseB * (radius / ellipseA);
                // Rotate by discAngle
                const dx = x - holePos.x;
                const dy = y - holePos.y;
                const rotatedX = holePos.x + dx * Math.cos(discAngle) - dy * Math.sin(discAngle);
                const rotatedY = holePos.y + dx * Math.sin(discAngle) + dy * Math.cos(discAngle);
                x = rotatedX + viewOffset.x;
                y = rotatedY + viewOffset.y;
                ctx.save();
                ctx.globalAlpha = 0.22 + Math.random() * 0.28;
                ctx.beginPath();
                ctx.arc(x, y, 1.2 + Math.random() * 1.8, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,220,0.85)';
                ctx.shadowColor = '#fffbe0';
                ctx.shadowBlur = 12;
                ctx.fill();
                ctx.restore();
            }
            ctx.globalCompositeOperation = 'source-over';
            if (bgLoaded) {
                ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            viewOffset.x = (mouse.x - holePos.x) * 0.03;
            viewOffset.y = (mouse.y - holePos.y) * 0.03;
            ctx.globalCompositeOperation = 'lighter';
            planets.forEach(p => { p.update(); p.draw(); });
            miniPlanets.forEach(mp => { mp.update(); mp.draw(); });
            bodies.forEach(b => { b.update(); if (Math.sin(b.angle) < 0) b.draw(); });
            particles.forEach(p => { p.update(); p.draw(false); });
            for (let i = sparks.length - 1; i >= 0; i--) {
                const s = sparks[i];
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                ctx.fillStyle = s.color + (s.life / 20).toFixed(2) + ")";
                ctx.fill();
                s.x += s.dx;
                s.y += s.dy;
                s.r *= 0.93;
                s.life--;
                if (s.life < 0) sparks.splice(i, 1);
            }
            ctx.globalCompositeOperation = 'source-over';
            // Glow efekt na horizont černé díry (jen okraj, střed zůstává černý)
            ctx.save();
            ctx.globalAlpha = 0.22;
            ctx.shadowColor = '#ffeedd';
            ctx.shadowBlur = 38;
            ctx.beginPath();
            ctx.arc(holePos.x + viewOffset.x * 0.5, holePos.y + viewOffset.y * 0.5, 70, 0, Math.PI * 2);
            ctx.fillStyle = '#ffeedd';
            ctx.fill();
            ctx.restore();
            // Černý střed černé díry
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(holePos.x + viewOffset.x * 0.5, holePos.y + viewOffset.y * 0.5, 65, 0, Math.PI * 2);
            ctx.fill();
            // Add dense dust near black hole, aligned with accretion disc
            const dustCount = 220;
            for (let i = 0; i < dustCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 70 + Math.random() * 45;
                // Elliptical coordinates with disc tilt
                let x = holePos.x + Math.cos(angle) * ellipseA * (radius / ellipseA);
                let y = holePos.y + Math.sin(angle) * ellipseB * (radius / ellipseA);
                // Rotate by discAngle
                const dx = x - holePos.x;
                const dy = y - holePos.y;
                const rotatedX = holePos.x + dx * Math.cos(discAngle) - dy * Math.sin(discAngle);
                const rotatedY = holePos.y + dx * Math.sin(discAngle) + dy * Math.cos(discAngle);
                x = rotatedX + viewOffset.x;
                y = rotatedY + viewOffset.y;
                ctx.save();
                ctx.globalAlpha = 0.18 + Math.random() * 0.22;
                ctx.beginPath();
                ctx.arc(x, y, 2.2 + Math.random() * 2.8, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(220,220,220,0.7)';
                ctx.shadowColor = '#fffbe0';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.restore();
            }
            ctx.globalCompositeOperation = 'lighter';
            planets.forEach(p => p.draw());
            miniPlanets.forEach(mp => mp.draw());
            bodies.forEach(b => { if (Math.sin(b.angle) >= 0) b.draw(); });
            particles.forEach(p => p.draw(true));
            requestAnimationFrame(animate);
        }
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        animate();
    </script>
</body>

</html>
